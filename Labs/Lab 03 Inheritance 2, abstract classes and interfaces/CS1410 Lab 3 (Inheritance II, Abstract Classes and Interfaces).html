<!DOCTYPE html>
<!-- saved from url=(0147)https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#0 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  
  <title>CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)</title>
  <link rel="stylesheet" href="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/css">
  <link rel="stylesheet" href="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/icon">
  <link rel="stylesheet" href="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<script src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/analytics.js.download"></script></head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" environment="web" category="null"></google-codelab-analytics>
  <google-codelab codelab-gaid="" id="jpd-2021-lab3" environment="web" feedback-link="mailto:a.garcia-dominguez@aston.ac.uk" selected="0" google-codelab-ready="" codelab-title="CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)" anayltics-ready="anayltics-ready"><div id="drawer"><div class="codelab-time-container" style="display: none;"></div><div class="steps"><ol><li completed="" selected=""><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#0"><span class="step"><span>Preparing your environment</span></span></a></li><li><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#1"><span class="step"><span>Importing the project</span></span></a></li><li><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#2"><span class="step"><span>Generalise Launcher.draw to any Shape</span></span></a></li><li><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#3"><span class="step"><span>Scaling circles with downcasts</span></span></a></li><li><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#4"><span class="step"><span>Making Shape abstract</span></span></a></li><li><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#5"><span class="step"><span>Introducing the Drawable interface</span></span></a></li><li><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#6"><span class="step"><span>Submit to AutoFeedback and Blackboard</span></span></a></li></ol></div><div class="metadata"><a target="_blank" href="mailto:a.garcia-dominguez@aston.ac.uk"><i class="material-icons">bug_report</i> Report a mistake</a></div></div><div id="codelab-title"><div id="codelab-nav-buttons"><a href="https://vle.aston.ac.uk/" id="arrow-back"><i class="material-icons">close</i></a><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#" id="menu"><i class="material-icons">menu</i></a></div><h1 is-upgraded="" class="title">CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)</h1><div class="codelab-time-container" style="display: none;"></div><devsite-user></devsite-user></div><div id="main"><div id="steps"><google-codelab-step label="Preparing your environment" duration="0" step="1" selected=""><div class="instructions"><div class="inner"><h2 is-upgraded="" class="step-title">1. Preparing your environment</h2>
        <p>This lab requires Java 11 or newer, and a recent installation of <a href="https://www.eclipse.org/downloads/packages/release/2020-12/r/eclipse-ide-java-developers" target="_blank">Eclipse for Java Developers</a>.</p>
<h2 is-upgraded="">Using a lab computer?</h2>
<p>If you are using a lab computer or a student VDI machine, launch Eclipse 2019-06 through AstonApps (you will need to launch Java 11.0.5 first). Eclipse will start on its default workspace, which already has all dependencies set up. Eclipse should ask you to pick a workspace folder: you should pick a folder in your home drive (e.g. <code>H:\CS1OOP\eclipse</code>), so your projects are created inside that folder and are preserved after you turn off the lab PC.</p>


      </div></div></google-codelab-step><google-codelab-step label="Importing the project" duration="0" step="2"><div class="instructions"><div class="inner"><h2 is-upgraded="" class="step-title">2. Importing the project</h2>
        <p>Download the starting code from Blackboard. You don't need to unpack the <code>.zip</code> file.</p>
<p>Import the project by using "File - Import - Existing Projects into Workspace", then pick "Archive file" and select the <code>.zip</code> file you downloaded.</p>
<p>One project called <code>uk.ac.aston.oop.acint</code> should come up. Press OK to import this project.</p>
<p>Make sure the project works: go to the "Package Explorer" view and run the <code>Run ACInt GUI</code> launch file that is appropriate to your operating system, by right-clicking on it and selceting "Run As - Run ACInt GUI". You should see something like this:</p>
<p class="image-container"><img alt="Screenshot of initial version" src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/ad43eed2864e57ae.png"></p>


      </div></div></google-codelab-step><google-codelab-step label="Generalise Launcher.draw to any Shape" duration="0" step="3"><div class="instructions"><div class="inner"><h2 is-upgraded="" class="step-title">3. Generalise Launcher.draw to any Shape</h2>
        <p>We will now change <code>Launcher#draw</code> so it works over an array of <code>Shape</code>s, rather than directly with various variables of different types. We can do this because <code>Rectangle</code>, <code>Circle</code> and <code>Ellipse</code> all extend <code>Shape</code>, so we can treat any of them as a <code>Shape</code>.</p>
<h2 is-upgraded="">Adding an array of shapes to Launcher</h2>
<p><em>Step 1.</em> Add a private field called <code>shapes</code> of type <code>Shape[]</code> to the <code>Launcher</code> class. This array will store all the shapes we draw on the screen: we won't need to have one variable for each different shape anymore.</p>
<p><em>Step 2.</em> Right before the first call to <code>draw</code> in the <code>start</code> method in <code>Launcher</code>, add new code that will:</p>
<ol type="1">
<li>Set <code>shapes</code> to a new array with space for 3 <code>Shape</code>s.</li>
<li>Set position 0 to a new <code>Rectangle</code>, with the same parameters used in <code>draw</code>.</li>
<li>Set position 1 to a new <code>Circle</code>, with the same parameters used in <code>draw</code>.</li>
<li>Set position 2 to a new <code>Ellipse</code>, with the same parameters used in <code>draw</code>.</li>
</ol>
<p><em>Step 3.</em> Change the <code>draw</code> method in <code>Launcher</code>:</p>
<ol type="1">
<li>Remove the <code>r</code>, <code>c</code> and <code>e</code> variables.</li>
<li>Before the line that changes <code>iFrame</code>, add a loop over the <code>shapes</code> array that calls <code>draw</code> over each of its elements.</li>
<li>Run the program now: it should look similar to before, except the shapes will not move anymore.</li>
</ol>
<p>Remember that you can mix shapes of different kinds in <code>shapes</code> because they all extend <code>Shape</code>. While the elements in <code>shapes</code> may have different actual (dynamic) types, they all have the same declared (static) type.</p>
<h2 is-upgraded="">Moving all shapes with Shape.move()</h2>
<p>In the previous section, we made it to <code>draw</code> could just loop over all <code>Shape</code>s and ask them to <code>draw</code> themselves. You will now add a <code>move</code> method to <code>Shape</code> that will allow you to move any shape, and we will use it to have the shapes move.</p>
<p><em>Step 4.</em> Add to <code>Shape</code> a new <code>move</code> method that takes a <code>GraphicsContextWrapper</code> and two <code>double</code>s: the distance to move along the X axis (<code>dx</code>), and the distance to move along the Y axis (<code>dy</code>). The method should:</p>
<ol type="1">
<li>Increment the upper left X coordinate by <code>dx</code>.</li>
<li>Increment the upper left Y coordinate by <code>dy</code>.</li>
<li>If the right edge of the shape (upper left X coordinate + width) is beyond the right edge of the screen (<code>gc.width()</code>), clip the upper left X coordinate to <code>gc.width() - width</code>.</li>
<li>If the bottom edge of the shape (upper left Y coordinate + height) is beyond the bottom edge of the screen (<code>gc.height()</code>), clip the upper left Y coordinate to <code>gc.height() - height</code>.</li>
</ol>
<p><em>Step 5.</em> Inside the loop in <code>draw</code>, make your shapes move 1 unit to the right and down on every frame (in JavaFX, <code>(0, 0)</code> is the upper left corner). Run the program, and you should see the shapes move to the right and down, and then settle on the bottom right corner. It should look like this:</p>
<p class="image-container"><img alt="Final positions" src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/95e08b71a52a63d.png"></p>


      </div></div></google-codelab-step><google-codelab-step label="Scaling circles with downcasts" duration="0" step="4"><div class="instructions"><div class="inner"><h2 is-upgraded="" class="step-title">4. Scaling circles with downcasts</h2>
        <p>Sometimes, we will be unable to add a method to the root of an inheritance hierarchy (like we did for <code>move</code>). In such case, we may use <em>downcasting</em> to do something different depending on the dynamic type of a variable.</p>
<p>Downcasting is the practice of taking a value of type <code>Superclass</code> and telling Java to treat it as a <code>Subclass</code>. For instance, we could take a value of type <code>Shape</code> and force Java to treat it as a <code>Circle</code>. This only works if that <code>Shape</code> really is a <code>Circle</code> - otherwise you will crash the program. To be sure, you will want to check first with the <code>instanceof</code> operator, like this:</p>
<pre><code><span class="typ">Shape</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="com">/* some code */</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="kwd">instanceof</span><span class="pln"> </span><span class="typ">Circle</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// We know that s really is a Circle now, so we can cast</span><span class="pln">
  </span><span class="com">// s to a Circle and assign it to a Circle variable</span><span class="pln">
  </span><span class="typ">Circle</span><span class="pln"> c </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Circle</span><span class="pun">)</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// s wasn't really a Circle (could be a Rectangle instead, for instance)</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>In this section, you will be adding scaling <em>only</em> to <code>Circle</code>s, and making them smaller and smaller over time.</p>
<p><em>Step 1.</em> Make <code>width</code> and <code>height</code> in <code>Shape</code> protected, so you can modify them in the next step.</p>
<p><em>Step 2.</em> Add a <code>scale</code> method to <code>Circle</code> that takes a <code>double ratio</code> and multiplies both the width and the height by that ratio. For instance, if we call <code>c.scale(0.5)</code>, the circle should end up with half its original width and height.</p>
<p><em>Step 3.</em> Inside the loop in <code>Launcher.draw</code>, use <code>instanceof</code> to check if the current <code>Shape</code> is a <code>Circle</code>. If it is, downcast it to a <code>Circle</code> and call <code>scale(0.99)</code> on it.</p>
<p>Try running your application. Things should still move the same, but the circle should become smaller and smaller.</p>


      </div></div></google-codelab-step><google-codelab-step label="Making Shape abstract" duration="0" step="5"><div class="instructions"><div class="inner"><h2 is-upgraded="" class="step-title">5. Making Shape abstract</h2>
        <p>Shape has a meaningless <code>draw</code> method: we cannot really draw anything of the screen, so all we could do is print a message reminding the developer that they forgot to override the method in a subclass implementing a specific shape (e.g. a Rectangle). We only needed this <code>draw</code> method to ensure that all Shape subclasses had it.</p>
<p>For this reason, we will change the <code>draw</code> method to be <code>abstract</code>. With this, we will still require all <code>Shape</code> subclasses to provide a way to draw themselves, but instead of relying on class authors to remember to override <code>draw</code>, we will leave it as a "gap" to be filled. This will be enforced by the Java compiler. <code>abstract</code> methods have no body, and any classes with <code>abstract</code> methods must be <code>abstract</code> themselves. An <code>abstract</code> class cannot be instantiated (<code>new AbstractClass(...)</code> will not compile).</p>
<p><em>Step 1.</em> Change the <code>Shape</code> class so the <code>draw</code> method looks like this:</p>
<pre><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> draw</span><span class="pun">(</span><span class="typ">GraphicsContext</span><span class="pln"> gc</span><span class="pun">);</span></code></pre>
<p>You should be seeing a compilation error now: the compiler is saying that an <code>abstract</code> method can only be defined in an <code>abstract</code> class.</p>
<p><em>Step 2.</em> Fix the error by making <code>Shape</code> abstract as well:</p>
<pre><code><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Shape</span><span class="pln"> </span><span class="pun">{</span></code></pre>
<p>Now the code should compile. Run it and make sure it works like before.</p>
<p>We have not really changed the behaviour of the program, but now the compiler will enforce that plain <code>Shape</code>s cannot be created, and that any concrete (non-abstract) <code>Shape</code> subclasses will be providing a <code>draw</code> method of their own.</p>
<p>As said before, <code>abstract</code> methods are used to leave gaps in a class, for subclasses to fill in.</p>


      </div></div></google-codelab-step><google-codelab-step label="Introducing the Drawable interface" duration="0" step="6"><div class="instructions"><div class="inner"><h2 is-upgraded="" class="step-title">6. Introducing the Drawable interface</h2>
        <p>Right now, the <code>Launcher</code> class can only draw things that extend from <code>Shape</code>. However, this is very limiting, because a class can only extend one other class. Ideally, we'd like to have our <code>Launcher</code> work with anything that has a <code>draw</code> method and a <code>move</code> method, regardless of which class it extends.</p>
<p>This is what interfaces are for. We are going to create a <code>Drawable</code> interface that represents anything we can <code>draw</code> and <code>move</code>, and we are going to change our program to use it. Then we are going to create a <code>Cross</code> class which implements <code>Drawable</code> and does <em>not</em> extend <code>Shape</code>, and we will use it in <code>Launcher</code>.</p>
<h2 is-upgraded="">Creating Drawable and using it from Launcher</h2>
<p><em>Step 1.</em> First, create the interface by right-clicking on the <code>uk.ac.aston.oop.acint.shapes</code> package in the "Package Explorer" view, and use "New - Interface". Fill in the name of the interface ("Drawable") and press OK. The interface should now be open on the editor area in your Eclipse window.</p>
<p><em>Step 2.</em> Add the <code>draw</code> and <code>move</code> methods to the interface, with the same arguments and return type as in <code>Shape</code>, but without a body.</p>
<p><em>Step 3.</em> Go to <code>Shape</code> and make it implement <code>Drawable</code>:</p>
<ol type="1">
<li>Add <code>implements Drawable</code> to the class declaration (the line with <code>public class Shape</code>).</li>
<li>Remove the abstract <code>draw</code> method: you are already inheriting the abstract method from the <code>Drawable</code> interface.</li>
<li>Add <code>@Override</code> to the <code>move</code> method: it is now implementing the methods in the <code>Drawable</code> interface.</li>
</ol>
<p><em>Step 4.</em> Change <code>Launcher</code> so instead of <code>Shape[] shapes</code> you have <code>Drawable[] drawables</code>. You will have to change the field, and change a few other locations in the file.</p>
<p>After you do all this, try running your program: it should work the same as before.</p>
<h2 is-upgraded="">Implementing Drawable in Cross</h2>
<p><em>Step 5.</em> Create a new <code>Cross</code> class in the <code>uk.ac.aston.oop.acint.shapes</code> package.</p>
<p><em>Step 6.</em> Make <code>Cross</code> implement <code>Drawable</code>.</p>
<p><em>Step 7.</em> Add a protected <code>static final int</code> field called <code>SIZE</code> and set it to 20.</p>
<p><em>Step 8.</em> Add two <code>double</code> fields to store the X and Y position of the center of the cross (e.g. <code>centerX</code> and <code>centerY</code>).</p>
<p><em>Step 8.</em> Add a constructor that takes two <code>double</code>s with the position of the center of the cross, and stores them in the two fields from before.</p>
<p><em>Step 9.</em> Implement the <code>draw</code> method. Use the new <code>line</code> method in <code>GraphicsContextWrapper</code> to draw two lines:</p>
<ol type="1">
<li>From (centerX - SIZE/2, centerY - SIZE/2) to (centerX + SIZE/2, centerY + SIZE/2).</li>
<li>From (centerX + SIZE/2, centerY - SIZE/2) to (centerX - SIZE/2, centerY + SIZE/2).</li>
</ol>
<p><em>Step 10.</em> Implement the <code>move</code> method. Move the center as you did for the upper left corner in <code>Shape.move</code>, and ensure you clip the center position in a similar way:</p>
<ul>
<li>If the right edge of the cross would go over the right edge, clip it to the right edge.</li>
<li>If the bottom edge of the cross would go over the bottom edge, clip it to the bottom edge.</li>
</ul>
<h2 is-upgraded="">Adding Cross to Launcher</h2>
<p><em>Step 11.</em> Go back to <code>Launcher</code> and change the <code>start</code> method so the array has space for 4 <code>Drawable</code>s instead of 3.</p>
<aside class="warning"><p>Keep in mind that instead of creating an array of <code>Shape</code>s, you should now be creating an array of <code>Drawable</code>s. This is because of an interesting bit of how Java arrays work:  </p>
<ul>
<li>A <code>Shape[]</code> is-a <code>Drawable[]</code>: you can assign an array of <code>Shape</code>s to a variable of type <code>Drawable[]</code>, because it is true that all elements in a <code>Shape[]</code> are also <code>Drawable</code>.</li>
<li>However, our <code>Cross</code> is <code>Drawable</code> but not a <code>Shape</code>, so we cannot put it in a <code>Shape[]</code>: if you did that, the program would crash with an <code>ArrayStoreException</code>.</li>
</ul>
</aside>
<p><em>Step 12.</em> Set the fourth position (position 3) to a new <code>Cross</code> centered at (60, 60).</p>
<p>That's it! You should be able to run the program and watch an X-shaped cross move down and to the right with everything else, and settling on the bottom right corner of the screen.</p>
<p>The interesting thing is that <code>Cross</code> did not have to extend <code>Shape</code> at all, unlike before. This means it could have extended anything else you wanted. Interfaces are generally useful to allow different pieces of code to communicate, without forcing anyone to extend a specific class.</p>


      </div></div></google-codelab-step><google-codelab-step label="Submit to AutoFeedback and Blackboard" duration="0" step="7"><div class="instructions"><div class="inner"><h2 is-upgraded="" class="step-title">7. Submit to AutoFeedback and Blackboard</h2>
        <p>Now that you have completed the lab, you should use the <code>Submit Lab 3 to AutoFeedback</code> file that corresponds to your operating system to submit your code to AutoFeedback.</p>
<p>For the details on how to use AutoFeedback, please refer to the last section of Lab 1.</p>
<p>In this lab, we didn't ask you to write any tests: instead, AutoFeedback has its own tests that check the various things you should have done as part of this lab. Please review the provided feedback, and let us know if anything is unclear.</p>
<p>Once you have passed the tests from AutoFeedback, you can simply upload the <code>submission.zip</code> file it generated to Blackboard.</p>


      </div></div></google-codelab-step></div><div id="controls"><div id="fabs"><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#" id="previous-step" title="Previous step" disappear="">Back</a><div class="spacer"></div><a href="https://vle.aston.ac.uk/bbcswebdav/pid-2177298-dt-content-rid-14759192_1/courses/2020_CS1OOP_P1_P2/TP2/week03-inh2-acint/jpd-2021-lab3/index.html#" id="next-step" title="Next step">Next</a><a href="https://vle.aston.ac.uk/" id="done" hidden="" title="Codelab complete">Done</a></div></div></div></google-codelab>

  <script src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/native-shim.js.download"></script>
  <script src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/custom-elements.min.js.download"></script>
  <script src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/prettify.js.download"></script>
  <script src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/codelab-elements.js.download"></script>
  <script src="./CS1410 Lab 3 (Inheritance II, Abstract Classes and Interfaces)_files/api.js.download"></script>



</body></html>